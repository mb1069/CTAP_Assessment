\documentclass[british,11pt,a4paper]{article}
\usepackage[british]{babel}
\usepackage[margin=0.5in, bottom=0.5in, top=0.5in, footskip=0.25in]{geometry}
\usepackage[titletoc]{appendix}
\usepackage{fancyhdr}
\usepackage{mathtools}
\usepackage[numbers]{natbib}
\usepackage{pgfplotstable,filecontents}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{wrapfig}
\usepackage{listings}
\usepackage{color}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\renewcommand{\arraystretch}{1.2}
\renewcommand\thesection{\arabic{section}}
\renewcommand\thesubsection{\roman{subsection}.}
\renewcommand\thesubsubsection{}
\newcommand*{\Appendixautorefname}{appendix}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}
\lfoot{Exam no: Y0076159}
\cfoot{\thepage}
\lstset{
  language=Haskell,
  columns=fixed,
  breaklines=true,
  basicstyle=\ttfamily\footnotesize
  }

\usepackage[nottoc]{tocbibind}
\usepackage{csvsimple}

\begin{document}
\title{CTAP Open Assessment}
\author{Exam no: Y0076159}
\date{\today}
\maketitle
\tableofcontents
\clearpage
\section{Breaking Stream Ciphers}
\subsection{Implementation and Challenge}
The stream cipher implementation, \autoref{app:stream} (written in Python),
can be found in appendix A. It can be ran using the Python 2.7.6
compiler with the command \lstinline{python stream.py}. This will produce the
challenge 25 bit output of 3 Lfsrs with initial states 97, 975 and 6420:

1 0 1 0 1 0 1 1 1 0 1 0 1 1 0 0 0 0 0 0 1 0 0 1 1

\subsubsection{Code description}
The class \lstinline{Lfsr} implements an LFSR with a tap sequence, size and initial state. It contains 2 methods:
\lstinline{calc_tap}, which calculates the tap value for the current register value, and \lstinline{shift} which
calculates the tap value, shifts the register and outputs the register's value. The 3 LFSR's are combined using
\lstinline{combine_lfsr_outputs}, which uses a lookup table to implement the boolean operation.

\subsection{Cryptanalysis}
\subsubsection{Analysis}

\begin{center}
	\begin{tabular}{@{}llll@{}}\label{tab:streamattack} \\
		\toprule \\
		Linear func.                  & Walsh transform & Attack No & Attack description                                           \\
		\midrule \\
		\(R_3\) & 0 \\
		\(R_2\)                       & 0               &           &                                                              \\
		\(R_2 \oplus R_3\)            & 0               &           &                                                              \\
		\(R_1\)                       & -4              & 1         & No dependencies, has a single outlier agreement (see figure) \\
		\(R_1 \oplus R_3\)            & -4              & 3         & Requires \(R_1\), attack with \(R_1 \oplus R_3 \oplus K\)    \\
		\(R_1 \oplus R_2\)            & 4               & 2         & Requires \(R_1\), attack with \(R_1 \oplus R_2 \oplus K\)    \\
		\(R_1 \oplus R_2 \oplus R_3\) & -4              &           &                                                              \\

		\bottomrule \\
	\end{tabular}
\end{center}
Using the walsh transform displayed in \autoref{app:streamattack}, we can implement a divide-and-conquer strategy.
As LFSR1 correlates quite strongly with the output (walsh value of -4, 2 agreements and 6 disagreements resulting in a probability of 2/8 that it will agree with the function's output, with a bias of 0.25),
it can be brute-forced to obtain it's key value by iterating over the space of subkeys, and finding the one with the highest agreement (subkey value 27, with an agreement of 0.253).

The next attack targets \(R_1 \oplus R_2\), as it has a walsh value of 4 (6 agreements and 2 disagreements resulting in a probability of 6/8, and a bias of -0.25).
The search space is reduced from \(O(n^{7} * n^{11})=O(n^{18})\) to \(O(n^7 + n^{11})=O(n^{11}))\) as we now know the key for LFSR1, allowing us to rapidly brute force the subkey for LFSR2 (value 1357, with agreement 0.247).

Finally LFSR3 can be attacked using \(R_1 \oplus R_3\), with a walsh value of -4 (same agreements, disagreements, probability of correlation and bias as previous).
As LFSR1's key is known, the search space is also reduced for this attack from \(O(n^{7} * n^{13})=O(n^{20})\) to \(O(n^7 + n^{13})=O(n^{13}))\). This resulted in the subkey for LFSR3 (value 7531, with agreemnt 0.245).

Using this strategy, we have succesfully attacked all 3 shift registers in a severely reduced search space (\(O(n^{7+11+13})>(O(n^{7}+n^{11}+n^{13})=O(n^{13}))\) (a reduction of 18 bits), resulting in the set of subkeys: 27, 1357, and 7531.

\subsubsection{Attack Implementation}
The Python program which implements this attack loads a keystream from \lstinline{stream.txt}, and begins by brute forcing the first register.
This is achieved by iterating over all possible keys, recording their agreement with the given data, and returning the key with the highest normalised agreement.
The next 2 LFSR's are then broken by iterating over each respective set of possible keys in combination with the output of LFSR1 using the previously known key.
This results in the set of initial states: \lstinline{lfsr1: 27, lfsr2: 1357, lfsr3: 7531}

\subsection{Improvement}
The current function's key weakness is the correlation of a single shift register (LFSR1) with the output: this allows the key to be brute forced in \(O(n^7)\), followed by the other two keys in \(On^{11}\) and \(On^{13}\).
As such, the current function is not correlation immune to any significant order.
By changing the combination function's output to 1 0 0 1 0 1 1 0 (two bit flips on L001 and L101), we can ensure the function
is correlation immune to order 2, as the Walsh-Hadamard values for \(R_1\),
\(R_2\),  \(R_3\),  \(R_1 \oplus R_2\), \(R_1 \oplus R_3\) and \(R_1 \oplus R_3\), are now 0,
and therefore have no exploitable correlation exist other than all 3 registers combined; this is visible in the table below.

\begin{center}
	\begin{tabular}{@{}lll@{}}\label{tab:walsh2} \\
		\toprule \\
		Input & \(f\) & \(w\) \\
		\midrule \\
		000   & 1     & 0     \\
		001   & 0     & 0     \\
		010   & 0     & 0     \\
		011   & 1     & 0     \\
		100   & 0     & 0     \\
		101   & 1     & 0     \\
		110   & 1     & 0     \\
		111   & 0     & -8    \\
		\bottomrule \\
	\end{tabular}
\end{center}
This would restrict the attack vector to a combination of LFSR1, LFSR2 and LFSR3 simultaneously, with a Walsh-Hadamard value of -8 for \(R_1 \oplus R_2 \oplus R_3\); this is acceptable as exploiting
this would require iterating over the complete keyset \(O(n^{7+11+13}) = O(n^{31})\), causing the time complexity to be significantly higher than the previous \(O(n^{13}))\).
\clearpage
\section{Differential Cryptanalysis}
\subsection{Implementation}

\subsubsection{Challenge}

\subsection{Cryptanalysis}
\subsubsection{Analysis}

\subsubsection{Implementation}
High differential characteristics for
X=2, Y=3, Diff = 8
X=8, Y=14, Diff= 8
X=5, Y=8, Diff = 8

X=12,Y=5, Diff = 6
X=13,Y=6, Diff = 6
X=4, Y=11, Diff = 6
X=9, Y=13, Diff = 6


\subsubsection{Challenge}

\subsection{Improvements}

\clearpage
\section{Timing Analysis}
\subsection{Example of a real-world timing analysis attack}
\cite{Kopf2009-mh},
\subsection{Countering timing attacks}

\subsubsection{Removing data or key dependent branching}
The simplest form of timing attack involves estimating the hamming weight in a key
based on the execution time of an encryption algorithm. This is possible due to
key-dependent branch execution, resulting in a correlation between cycle execution time
and key bit value. An example of this issue occurs in RC5
\cite{Handschuh1999} due to variations in the computational time of rotations.
Data-dependent computational requirements also occur in modular exponentiation, which is used by the RSA algorithm.
This form of attack can be mitigated by ensuring the algorithm does not conditionally branch,
causing it to take a longer but consistent time to execute the encryption.

\subsubsection{Noise}
Timing attacks can also be mitigating by randomising the execution time of the algorithm
Kocher \cite{kocher96timing} details a method of decreasing the accuracy of timing measurements
by adding random delays to the processing time, causing the need for a larger number of ciphertexts to attack
the algorithm. This produces a result similar to bucketing, where increasing the time spent waiting reduces performance but increases security, and vice-versa.

\subsubsection{Blinding}
Blinding is the obfurscation of data to harden RSA (or similar) algorithms to various side-channel attacks.
This involves the obfurscation of data before and after the execution of attackable sections of code,
resulting in un-usable information if the attacker uses a standard timing attack.
Kocher \cite{kocher96timing} has concluded this to be insufficient to fully mitigate timing attacks due to maliciously-designed modular exponeniator
causing timing spikes corresponding to exponent bits, revealing the hamming weight of the exponent.

\subsubsection{Balancing}
Balancing is a timing attack mitigation implemented in a program by executing every operation on the complement of the data as well as the data.
This diminishes the correlation to single data bits \cite{daemen-implementattacks}, resulting in a lack of correlation between hamming weight and timing data. This can be applied to a
large number of operations, such as fixed offset shifts, bitwise operations and arithmetic operations.
\subsubsection{Bucketing}
Bucketing is a method of trading off computational performance while limiting the benefit of timing attack measurements.
This was first achieved by Kopf \cite{Kopf2009-mh}, and consists of a discretization of possible execution times.
Bucketing is implemented by partitioning the system's execution times into intervals (called buckets) of variable length,
where computations wait until the end of the current bucket's time before returning results of a computation. The effectiveness of this method
can be varied to either minimise computational penalty (by reducing bucket size to minimise waiting) or force the attacker to increase the sampling rate used to conduct the timing attack.
Kopf does provide an algorithm to find the optimal bucket size and frequency, allowing the program to maximise both it's performance and security.

\subsubsection{Cache timing attacks}
Bernstein \cite{Bernstein05cache-timingattacks} details an attack vector based on cache hits and misses:
this is applicable to data-dependent lookups, for example in the AES algorithm.
On the assumption that the attacker can monitor the time taken by the victim to encrypt each character in the input,
a split in the location of a stored array (where part is stored on faster cache, and part is stored on slower ram) will reveal
which section of the array was requested. In the case of AES, this could indicate which part of the S-box was requested, and therefore
which value was inputted to the S-box. This attack vector can be mitigated by removing S-box lookups and instead implementing them using
constant time bit operations \cite{Bernstein05cache-timingattacks}; this results in a timing attack immune software which is unfortunately much slower than using lookups.
Bernstein also notes that maintaining an S-box in cache is not reliably feasible due to lines of the S-box being kicked out of cache by
computation other than AES. Similarly, cache-levels can also cause variations in access times for S-boxes which are entirely stored in cache,
mitigating the measurable time difference but leaving some information to be attacked.





\clearpage
\section{Open cryptography}
\subsubsection{Should the public be allowed to use strong cryptographic algorithms?}
http://web.cs.ucdavis.edu/~rogaway/papers/moral-fn.pdf
https://www.technologyreview.com/s/519281/cryptographers-have-an-ethics-problem/
https://www.cs.kent.ac.uk/people/staff/eab2/talks/Cryptographylawethics.pdf

\clearpage
\begin{appendices}
	\section{Stream.py}\label{app:stream}
	\lstinputlisting[language=Python]{../part1/stream.py}
  \clearpage

	\section{Walsh transform of combining function}\label{app:walsh}
  \pgfplotstabletypeset[columns/Output/.style={string type}, col sep=comma,
       columns={Output,L000, L001, L010, L011, L100, L101, L110, L111},
      ]{walsh_correlations.csv}
  \clearpage

  \section{Streamattack.py}\label{app:streamattack}
  \lstinputlisting[language=Python]{../part1/stream_attack.py}
  \clearpage

	\section{Difference distribution table}\label{app:diff_distrib_tab}
	% \lstinputlisting[language={}]{diff_distrib_table.csv}
  \pgfplotstabletypeset[col sep=comma,
       columns={Output Difference, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
      ]{diff_distrib_table.csv}
  \clearpage
\end{appendices}
\clearpage
\bibliographystyle{IEEEtranSN}
\bibliography{references}
\end{document}
