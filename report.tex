\documentclass[british,11pt,a4paper]{article}
\usepackage[british]{babel}
\usepackage[margin=0.5in, bottom=0.5in, top=0.5in, footskip=0.25in]{geometry}
\usepackage[titletoc]{appendix}
\usepackage{fancyhdr}
\usepackage{mathtools}
\usepackage[numbers]{natbib}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{wrapfig}
\usepackage{listings}
\usepackage{color}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\renewcommand{\arraystretch}{1.2}
\renewcommand\thesection{\arabic{section}}
\renewcommand\thesubsection{\roman{subsection}.}
\renewcommand\thesubsubsection{}
\newcommand*{\Appendixautorefname}{appendix}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}
\lfoot{Exam no: Y0076159}
\cfoot{\thepage}
\lstset{
  language=Haskell,
  columns=fixed,
  breaklines=true,
  basicstyle=\ttfamily\footnotesize
  }

\begin{document}
\title{CTAP}
\author{Exam no: Y0076159}
\date{\today}
\maketitle
\tableofcontents
\clearpage
\section{Breaking Stream Ciphers}
\subsection{Implementation and Challenge}
The stream cipher implementation, \autoref{app:stream} (written in Python),
can be found in appendix A. It can be ran using the Python 2.7.6
compiler with the command \lstinline{python stream.py}. This will produce the
challenge 25 bit output of 3 Lfsrs with initial states 97, 975 and 6420:

1 0 1 0 1 0 1 1 1 0 1 0 1 1 0 0 0 0 0 0 1 0 0 1 1

\subsubsection{Code description}
The class \lstinline{Lfsr} implements an LFSR with a tap sequence, size and initial state. It contains 2 methods:
\lstinline{calc_tap}, which calculates the tap value for the current register value, and \lstinline{shift} which
calculates the tap value, shifts the register and outputs the register's value. The 3 LFSR's are combined using
\lstinline{combine_lfsr_outputs}, which uses a lookup table to implement the boolean operation.

\subsection{Cryptanalysis}
\subsubsection{Analysis}

\begin{center}
\begin{tabular}{@{}llll@{}}\label{tab:streamattack} \\
  \toprule \\
  Linear func. & Walsh transform & Attack No & Attack description \\
  \midrule \\
  \(R_3\) & 0 \\
  \(R_2\) & 0 & & \\
  \(R_2 \oplus R_3\) & 0 & & \\
  \(R_1\) & -4 & 1 & No dependencies, has a single outlier agreement (see figure)\\
  \(R_1 \oplus R_3\) & -4 & 3 & Requires \(R_1\), attack with \(R_1 \oplus R_3 \oplus K\)\\
  \(R_1 \oplus R_2\) & 4 & 2 & Requires \(R_1\), attack with \(R_1 \oplus R_2 \oplus K\)\\
  \(R_1 \oplus R_2 \oplus R_3\) & -4 & & \\

  \bottomrule \\
\end{tabular}
\end{center}
Using the walsh transform displayed in \autoref{app:streamattack}, we can implement a divide-and-conquer strategy.
As LFSR1 correlates quite strongly with the output (walsh value of -4, 2 agreements and 6 disagreements resulting in a probability of 2/8 that it will agree with the function's output, with a bias of 0.25),
it can be brute-forced to obtain it's key value by iterating over the space of subkeys, and finding the one with the highest agreement (subkey value 27, with an agreement of 0.253).

The next attack targets \(R_1 \oplus R_2\), as it has a walsh value of 4 (6 agreements and 2 disagreements resulting in a probability of 6/8, and a bias of -0.25).
The search space is reduced from \(O(n^{7} * n^{11})=O(n^{18})\) to \(O(n^7 + n^{11})=O(n^{11}))\) as we now know the key for LFSR1, allowing us to rapidly brute force the subkey for LFSR2 (value 1357, with agreement 0.247).

Finally LFSR3 can be attacked using \(R_1 \oplus R_3\), with a walsh value of -4 (same agreements, disagreements, probability of correlation and bias as previous).
As LFSR1's key is known, the search space is also reduced for this attack from \(O(n^{7} * n^{13})=O(n^{20})\) to \(O(n^7 + n^{13})=O(n^{13}))\). This resulted in the subkey for LFSR3 (value 7531, with agreemnt 0.245).

Using this strategy, we have succesfully attacked all 3 shift registers in a severely reduced search space (\(O(n^{7+11+13})>(O(n^{7}+n^{11}+n^{13})=O(n^{13}))\) (a reduction of 18 bits), resulting in the set of subkeys: 27, 1357, and 7531.

\subsubsection{Attack Implementation}
The Python program which implements this attack loads a keystream from \lstinline{stream.txt}, and begins by brute forcing the first register.
This is achieved by iterating over all possible keys, recording their agreement with the given data, and returning the key with the highest normalised agreement.
The next 2 LFSR's are then broken by iterating over each respective set of possible keys in combination with the output of LFSR1 using the previously known key.
This results in the set of initial states: \lstinline{lfsr1: 27, lfsr2: 1357, lfsr3: 7531}

\subsection{Improvement}
By changing the combination function to 1 0 0 1 0 1 1 0, we can ensure the function
is correlation immune to order 2, as the Walsh-Hadamard values for \(R_1\),
 \(R_2\),  \(R_3\),  \(R_1 \oplus R_2\), \(R_1 \oplus R_3\) and \(R_1 \oplus R_3\), are now 0,
 and therefore have no exploitable correlation. This would leave a Walsh-Hadamard value of
 -8 for \(R_1 \oplus R_2 \oplus R_3\), which is acceptable as exploiting this would require iterating over the complete keyset \(O(n^{7+11+13}) = O(n^{31})\).

The given combining function has order 1 correlations with \(R_1\) and \(R_3\).
It has negative correlations with both, so it must be tweaked by increasing
the correlation with them. To keep the function balanced, for any bit which
is flipped, an opposite bit must also be flipped. The value of the combining
function \(f\) at 1 is 1, but the value of \(R_1\) and \(R_3\) is 0. The
value of the combining function \(f\) at 1010 is 0, but the value of \(R_1\)
 and \(R_3\) is 1. Flipping these two bits will increase the correlation with
  \(R_1\) and \(R_3\) while keeping the function balanced. This creates a new
   negative correlation with \(R_4\) of -4, although the correlation with \(R_1\)
    is gone and the correlation with \(R_3\) is increased to -4. The correlation
    with \(R_4\) and \(R_3\) can be removed. Each changing of a disagreement to
  an agreement adds 2, since a -1 is changed to a +1. So 4 can be added by doing
  this twice. Two bitflips are needed to keep the function balanced, so by making
   sure that both bitflips improve the correlation with \(R_4\) and \(R_3\), the walsh values of both will be changed to 0. A candidate for this change is 1100 and 1111. At 1100, \(f\) is 1 but \(R_4\) and \(R_3\) are 0. At 1111, \(f\) is 0 but \(R_4\) and \(R_3\) are 1. So, these two values can be flipped. This makes the function correlation immune of order 1. The function and its walsh hadamard values are given below:
\begin{center}
  \begin{tabular}{@{}lll@{}}\label{tab:walsh2} \\
    \toprule \\
    Input & \(f\) & \(w\) \\
    \midrule \\
    0000 & 1 & 0 \\
    0001 & 0 & 0 \\
    0010 & 0 & 0 \\
    0011 & 1 & 0 \\
    0100 & 0 & 0 \\
    0101 & 1 & -8 \\
    0110 & 1 & 0 \\
    0111 & 0 & -8 \\
    1000 & 1 & 0 \\
    1001 & 0 & 0 \\
    1010 & 1 & 0 \\
    1011 & 0 & 0 \\
    1100 & 0 & 0 \\
    1101 & 1 & 8 \\
    1110 & 0 & 0 \\
    1111 & 1 & -8 \\
    \bottomrule \\
  \end{tabular}
\end{center}
This function cannot beattacked without brute-forcing two registers at once,
because there are no correlations with single registers. This makes the time
complexity of the attack much higher. The lowest possible complexity that could be achieved with a function with order-1 immunity is the sizes of the smallest two registers multiplied together, plus the sizes of the other two registers. This could be used in the case where there is a correlation with the smallest two registers exclusive-ored together, and correlations between one of those two registers and each of the remaining two. In the case of this cipher, the complexity would be \(2^{7+11} + 2^{13} + 2^{15}\) which is approimately \(2^{18}\), which is 8 times larger than the attack performed in the previous section. In the case of the function defined here, the only order-2 correlation is with \(R_2 \oplus R_4\), so the complexity will be \(2^{11} = 2048\) times larger, since brute forcing \(R_2\) and \(R_4\) requires a search over \(2^{11 + 15 = 26}\).

In summary, the cipher is made significantly more difficult to attack by the new function, requiring a brute-force search of size \(2^{26}\) rather than \(2^{15}\). Even in the best possible case, a function with order-1 correlation immunity would require a brute force search of at least \(2^{18}\) rather than \(2^{15}\).

\clearpage
\section{Linear Cryptanalysis}
\subsection{Implementation}

\subsubsection{Challenge}

\subsection{Cryptanalysis}
\subsubsection{Analysis}

\subsubsection{Implementation}

\subsubsection{Challenge}

\subsection{Improvements}

\clearpage
\section{Countering Side Channels}
\subsection{Techniques to counter timing and power analysis}
\subsubsection{Removing secret data-dependent branches}
\subsubsection{Removing table lookups on secret indexes}
\subsubsection{Blinding}
\subsubsection{Masking}
\subsubsection{Noise}
\subsubsection{Balancing}
\subsubsection{Bucketing}
\subsection{Other potential side channels}

\clearpage
\section{Ethics of Cryptanalysis}
\subsubsection{Should cryptanalysis be a public academic discipline?}

\clearpage
\begin{appendices}
  \section{Stream.py}\label{app:stream}
  \lstinputlisting[language=Python]{part1/stream.py}

  \section{Walsh transform of combining function}\label{app:walsh}
  \lstinputlisting[language={}]{report/walsh_correlations.txt}

  % \section{Linear.hs}\label{app:linear}
  % \lstinputlisting[language=Haskell]{Linear.hs}
  %
  % \section{Linear approximation table for Heys modified block cipher}\label{app:lat}
  % \lstinputlisting[language={}]{lat.txt}
\end{appendices}
\clearpage
\bibliographystyle{IEEEtranN}
\bibliography{references}
\end{document}
